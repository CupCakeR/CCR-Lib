
public class CCR.Language
	_get _set url -- direct url to json file
	_get _set logger

	_get rawJson
	_get raw -- contains the raw json returned (as table)
	_get phrases -- contains the flattened strings

	--
	
	getLogger()
		return self.logger || CCR.Logger
	end

	--

	isReady()
		return self.phrases != nil
	end

	getPhrase(phrase, replacements, pluralizationValue)
		assert(self:isReady(), "called too early, not ready")
		assert(phrase, "no phrase to translate")

		if (pluralizationValue) then
			local singular
			if (tonumber(pluralizationValue)) then
				singular = pluralizationValue == 1
			elseif (pluralizationValue == true) then
				singular = select(2, next(replacements)) == 1
			else
				error("invalid pluralization value")
			end

			phrase ..= "."
			phrase ..= (singular && "singular" || "plural")
		end

		local str = self.phrases[phrase]
		if (!str) then
			return `UNKNOWN: ${phrase}`
		end

		if (replacements) then
			for k, v in pairs(replacements) do
				str = str:Replace(`:${k}:`, v)
			end
		end

		return str
	end

	--

	download()
		local promise = CCR.Promise()

		http.Fetch(self.url, (body, size, headers, code) =>
			if (code != 200) then
				self:getLogger():error(`i18n: http.Fetch failed with code ${code} - url: ${self.url}`)
				return promise:resolve()
			end

			local tbl = util.JSONToTable(body)
			if (!tbl) then
				self:getLogger():error(`i18n: invalid response body (not valid json)`)
				return promise:resolve()
			end

			self.rawJson = body

			promise:resolve(tbl)
		end)

		return promise
	end

	loadFromCache()
		local promise = CCR.Promise()

		local crc = util.CRC(self.url)
		local cached = file.Read(`ccr/languages/${crc}.txt`, "DATA")

		if (cached) then
			local str = util.Base64Decode(cached) -- i really dont want anyone to play around with shit in /data
			local tbl = util.JSONToTable(str)

			if (tbl) then
				promise:resolve(tbl)
			else
				self:getLogger():error(`i18n: cached language file contains invalid json`)
				promise:reject()
			end
		else
			promise:reject()
		end

		return promise
	end

	updateCache()
		local crc = util.CRC(self.url)
		local content = util.Base64Encode(self:getRawJson())

		file.Write(`ccr/languages/${crc}.txt`, content)
	end

	buildPhrases(tbl)
		local raw = self:getRaw()
		assert(raw, "no raw table to build phrases from")

		local copy = table.Copy(raw["phrases"])
		local flattened = CCR.FlattenTable(copy, ".", true)

		self.phrases = flattened
	end

	load()
		assert(self:getUrl(), "no url set")
		assert(self:getLogger(), "no console logger set")

		file.CreateDir(`ccr/languages`)

		self:download():next((tbl) =>
			if (!tbl) then
				self:getLogger():warning(`i18n: checking for a cached version`)
				return self:loadFromCache()
			end

			self.raw = tbl
		end):next(() =>
			self:buildPhrases()
			self:updateCache()

			local total = table.Count(self.phrases)
			self:getLogger():success(`i18n: successfully loaded ${total} translated phrase(s)`)

			hook.Run("CCR.OnLanguageLoaded", self)
		end, () =>
			self:getLogger():error(`i18n: failed to load language.`)
		end)
	end

	__tostring() return `CCR.Language` end
end

-- FIXME: maybe use this instead: https://github.com/Facepunch/garrysmod-requests/issues/1670#issuecomment-667499932

CCR.CanInitializeLanguage ||= false
hook.Add("InitPostEntity", "CCR.DoInitializeLanguage", function() -- NOTE: Dont call http shit too early?
	timer.Simple(3, function()
		CCR.CanInitializeLanguage = true
		hook.Run("CCR.DoInitializeLanguage")
	end)
end)